import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Button, 
  CircularProgress, 
  Alert,
  LinearProgress,
  Card,
  CardContent,
  Grid,
  Stepper,
  Step,
  StepLabel,
  Divider,
  useTheme,
  Fade,
  Chip
} from '@mui/material';

// Icons
import SlideshowIcon from '@mui/icons-material/Slideshow';
import PictureAsPdfIcon from '@mui/icons-material/PictureAsPdf';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import SettingsIcon from '@mui/icons-material/Settings';
import BrushIcon from '@mui/icons-material/Brush';
import BuildIcon from '@mui/icons-material/Build';
import DoneAllIcon from '@mui/icons-material/DoneAll';

// Import libraries for presentation generation
import pptxgen from 'pptxgenjs';
import { jsPDF } from 'jspdf';

const PresentationBuilder = ({ extractedContent, format, onBuildComplete }) => {
  const theme = useTheme();
  const [isBuilding, setIsBuilding] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const [error, setError] = useState(null);
  const [buildProgress, setBuildProgress] = useState(0);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [buildStage, setBuildStage] = useState(0);
  const [presentation, setPresentation] = useState(null);
  
  // Build stages
  const buildStages = [
    'Initializing',
    'Preparing content',
    'Creating slides',
    'Applying formatting',
    'Finalizing'
  ];
  
  // Function to generate PPTX presentation
  const generatePPTX = async () => {
    try {
      // Initialize presentation
      setBuildStage(0);
      setBuildProgress(10);
      
      const pptx = new pptxgen();
      
      // Set presentation properties
      pptx.author = 'PDF to Slides Converter';
      pptx.title = extractedContent.title || 'Converted Presentation';
      pptx.subject = 'Automatically generated from PDF document';
      
      // Prepare content
      setBuildStage(1);
      setBuildProgress(20);
      
      // Get the extracted slides content
      const slides = extractedContent.slides || [];
      
      // Create title slide
      const titleSlide = pptx.addSlide();
      
      titleSlide.addText(extractedContent.title || 'Converted Presentation', {
        x: '10%',
        y: '40%',
        w: '80%',
        h: '20%',
        fontSize: 44,
        color: '363636',
        bold: true,
        align: 'center'
      });
      
      titleSlide.addText('Generated by PDF to Slides Converter', {
        x: '10%',
        y: '60%',
        w: '80%',
        h: '10%',
        fontSize: 20,
        color: '9e9e9e',
        align: 'center'
      });
      
      // Create slides for each content piece
      setBuildStage(2);
      
      for (let i = 0; i < slides.length; i++) {
        // Update progress
        setCurrentSlide(i + 1);
        const slideProgress = 20 + Math.floor((i / slides.length) * 40);
        setBuildProgress(slideProgress);
        
        // Add a small delay to make the progress visible
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const slideContent = slides[i];
        const slide = pptx.addSlide();
        
        // Add title
        slide.addText(slideContent.title || `Slide ${i + 1}`, {
          x: '5%',
          y: '5%',
          w: '90%',
          h: '10%',
          fontSize: 24,
          color: '363636',
          bold: true
        });
        
        // Add content
        if (slideContent.content && slideContent.content.length > 0) {
          // Join paragraphs if there are multiple
          const contentText = Array.isArray(slideContent.content) 
            ? slideContent.content.join('\n\n') 
            : slideContent.content;
          
          slide.addText(contentText, {
            x: '5%',
            y: '20%',
            w: '90%',
            h: '65%',
            fontSize: 16,
            color: '363636',
            bullet: { type: 'bullet' }
          });
        }
        
        // Add images if available
        if (slideContent.images && slideContent.images.length > 0) {
          // In a real implementation, we would add actual images
          // For this demo, we'll simulate the image placement
          slide.addText('[Image placeholder]', {
            x: '30%',
            y: '60%',
            w: '40%',
            h: '20%',
            fontSize: 14,
            color: 'a0a0a0',
            align: 'center',
            fill: { color: 'f1f1f1' }
          });
        }
        
        // Add slide number
        slide.addText(`${i + 1}/${slides.length}`, {
          x: '90%',
          y: '95%',
          w: '10%',
          h: '5%',
          fontSize: 12,
          color: '9e9e9e',
          align: 'right'
        });
      }
      
      // Apply formatting
      setBuildStage(3);
      setBuildProgress(70);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Finalize
      setBuildStage(4);
      setBuildProgress(90);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // In a real implementation, we would generate and return the actual PPTX data
      // For this demo, we'll create a mock blob
      const presentationData = {
        format: 'pptx',
        slides: slides.length + 1, // Include title slide
        generatedAt: new Date().toISOString(),
        // In a real implementation, this would be the binary data or blob
        // pptx.write('blob') would be used to get the actual PPTX data
        data: 'pptx-presentation-data'
      };
      
      setBuildProgress(100);
      return presentationData;
      
    } catch (err) {
      console.error('Error generating PPTX:', err);
      throw new Error('Failed to generate PowerPoint presentation. Please try again.');
    }
  };
  
  // Function to generate PDF presentation
  const generatePDF = async () => {
    try {
      // Initialize
      setBuildStage(0);
      setBuildProgress(10);
      
      // Create new PDF document (A4 landscape)
      const pdf = new jsPDF({
        orientation: 'landscape',
        unit: 'mm',
        format: 'a4'
      });
      
      // Prepare content
      setBuildStage(1);
      setBuildProgress(20);
      
      // Get the extracted slides content
      const slides = extractedContent.slides || [];
      
      // Create title slide
      pdf.setFontSize(32);
      pdf.setTextColor(54, 54, 54); // #363636
      pdf.text(extractedContent.title || 'Converted Presentation', 148, 80, { align: 'center' });
      
      pdf.setFontSize(16);
      pdf.setTextColor(158, 158, 158); // #9e9e9e
      pdf.text('Generated by PDF to Slides Converter', 148, 100, { align: 'center' });
      
      // Create slides for each content piece
      setBuildStage(2);
      
      for (let i = 0; i < slides.length; i++) {
        // Add new page for each slide (except the first one which is the title)
        pdf.addPage();
        
        // Update progress
        setCurrentSlide(i + 1);
        const slideProgress = 20 + Math.floor((i / slides.length) * 40);
        setBuildProgress(slideProgress);
        
        // Add a small delay to make the progress visible
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const slideContent = slides[i];
        
        // Add title
        pdf.setFontSize(24);
        pdf.setTextColor(54, 54, 54); // #363636
        pdf.text(slideContent.title || `Slide ${i + 1}`, 20, 20);
        
        // Add content
        if (slideContent.content && slideContent.content.length > 0) {
          pdf.setFontSize(14);
          
          // Join paragraphs if there are multiple
          const contentArray = Array.isArray(slideContent.content) 
            ? slideContent.content 
            : [slideContent.content];
          
          // Print each paragraph
          let yPos = 40;
          for (const paragraph of contentArray) {
            // Split text into lines that fit within the page width
            const textLines = pdf.splitTextToSize(paragraph, 250);
            
            // Add each line
            for (const line of textLines) {
              pdf.text('• ' + line, 25, yPos);
              yPos += 8;
              
              // Check if we need to start a new page
              if (yPos > 190) {
                pdf.addPage();
                yPos = 20;
              }
            }
            
            // Add spacing between paragraphs
            yPos += 5;
          }
        }
        
        // Add slide number
        pdf.setFontSize(10);
        pdf.setTextColor(158, 158, 158); // #9e9e9e
        pdf.text(`${i + 1}/${slides.length}`, 270, 200, { align: 'right' });
      }
      
      // Apply formatting
      setBuildStage(3);
      setBuildProgress(70);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Finalize
      setBuildStage(4);
      setBuildProgress(90);
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // In a real implementation, we would return the actual PDF data
      // For this demo, we'll create a mock blob
      const presentationData = {
        format: 'pdf',
        slides: slides.length + 1, // Include title slide
        generatedAt: new Date().toISOString(),
        // In a real implementation, this would be the binary data or blob
        // pdf.output('blob') would be used to get the actual PDF data
        data: 'pdf-presentation-data'
      };
      
      setBuildProgress(100);
      return presentationData;
      
    } catch (err) {
      console.error('Error generating PDF:', err);
      throw new Error('Failed to generate PDF presentation. Please try again.');
    }
  };
  
  // Main build function
  const handleBuild = async () => {
    if (!extractedContent || !format) return;
    
    setIsBuilding(true);
    setIsComplete(false);
    setError(null);
    setBuildProgress(0);
    setCurrentSlide(0);
    setBuildStage(0);
    
    try {
      // Generate the presentation based on the selected format
      const presentationData = format === 'pptx' 
        ? await generatePPTX() 
        : await generatePDF();
      
      // Set the presentation data
      setPresentation(presentationData);
      setIsComplete(true);
      
      // Pass the presentation data to the parent component
      if (onBuildComplete) {
        onBuildComplete(presentationData);
      }
    } catch (err) {
      console.error('Error building presentation:', err);
      setError(err.message || 'An error occurred while building the presentation.');
    } finally {
      setIsBuilding(false);
    }
  };
  
  // Format-specific styling
  const formatStyles = {
    pptx: {
      color: '#D04423', // PowerPoint red
      icon: <SlideshowIcon />,
      name: 'PowerPoint'
    },
    pdf: {
      color: '#B30B00', // PDF red
      icon: <PictureAsPdfIcon />,
      name: 'PDF'
    }
  };
  
  return (
    <Paper elevation={3} sx={{ p: 3, my: 3, maxWidth: 800, mx: 'auto' }}>
      <Typography variant="h5" gutterBottom>
        Build Presentation
      </Typography>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}
      
      {isComplete ? (
        <Box sx={{ mt: 3 }}>
          <Alert 
            severity="success" 
            icon={<CheckCircleIcon fontSize="inherit" />}
            sx={{ mb: 3 }}
          >
            <Typography variant="body1">
              Your {format?.toUpperCase()} presentation has been successfully built!
            </Typography>
          </Alert>
          
          <Card variant="outlined" sx={{ mb: 3 }}>
            <CardContent>
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                <Box sx={{ 
                  mr: 2, 
                  color: formatStyles[format]?.color || theme.palette.primary.main 
                }}>
                  {formatStyles[format]?.icon || <SlideshowIcon fontSize="large" />}
                </Box>
                <Box>
                  <Typography variant="h6" component="div">
                    {extractedContent?.title || 'Generated Presentation'}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {presentation?.slides || 0} slides • {format?.toUpperCase()} format
                  </Typography>
                </Box>
              </Box>
              
              <Divider sx={{ my: 2 }} />
              
              <Typography variant="body2" paragraph>
                Your presentation is ready for download. Click the download button in the next step to save your file.
              </Typography>
              
              <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                <Chip 
                  label={`Ready for download`} 
                  color="success" 
                  size="small"
                  icon={<DoneAllIcon />}
                />
              </Box>
            </CardContent>
          </Card>
        </Box>
      ) : (
        <Box sx={{ mt: 3 }}>
          {isBuilding ? (
            <Box>
              <Typography variant="body1" gutterBottom>
                Building your {formatStyles[format]?.name || format?.toUpperCase()} presentation...
              </Typography>
              
              <Box sx={{ mt: 4, mb: 5 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                  <Typography variant="body2" color="text.secondary">
                    {currentSlide > 0 ? `Processing slide ${currentSlide}` : buildStages[buildStage]}
                  </Typography>
                  <Typography variant="body2" color="primary">
                    {buildProgress}%
                  </Typography>
                </Box>
                
                <LinearProgress 
                  variant="determinate" 
                  value={buildProgress} 
                  sx={{ height: 8, borderRadius: 1 }}
                />
              </Box>
              
              <Stepper activeStep={buildStage} alternativeLabel sx={{ mb: 3 }}>
                {buildStages.map((label, index) => (
                  <Step key={label}>
                    <StepLabel>{label}</StepLabel>
                  </Step>
                ))}
              </Stepper>
              
              <Box sx={{ mt: 3, mb: 2, textAlign: 'center' }}>
                <CircularProgress size={40} />
                <Typography variant="body2" sx={{ mt: 1 }} color="text.secondary">
                  This may take a moment for large presentations
                </Typography>
              </Box>
            </Box>
          ) : (
            <Box>
              <Box sx={{ mb: 3 }}>
                <Typography variant="body1" paragraph>
                  Ready to generate your {formatStyles[format]?.name || format?.toUpperCase()} presentation with {extractedContent?.slides?.length || 0} slides.
                </Typography>
                
                <Typography variant="body2" color="text.secondary" paragraph>
                  Click the button below to start the build process. This will convert your extracted content into a downloadable presentation.
                </Typography>
              </Box>
              
              <Grid container spacing={2} sx={{ mb: 3 }}>
                <Grid item xs={12} sm={6}>
                  <Card variant="outlined" sx={{ height: '100%' }}>
                    <CardContent>
                      <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold' }}>
                        Content Summary
                      </Typography>
                      <List dense disablePadding>
                        <ListItem disableGutters>
                          <ListItemIcon sx={{ minWidth: 36 }}>
                            <Box 
                              component="span" 
                              sx={{ 
                                display: 'flex', 
                                alignItems: 'center', 
                                justifyContent: 'center',
                                bgcolor: 'primary.main', 
                                color: 'white', 
                                width: 24, 
                                height: 24, 
                                borderRadius: '50%',
                                fontSize: 14
                              }}
                            >
                              {extractedContent?.slides?.length || 0}
                            </Box>
                          </ListItemIcon>
                          <ListItemText 
                            primary="Slides to generate"
                            primaryTypographyProps={{ variant: 'body2' }}
                          />
                        </ListItem>
                        
                        <ListItem disableGutters>
                          <ListItemIcon sx={{ minWidth: 36 }}>
                            <Box 
                              component="span" 
                              sx={{ 
                                display: 'flex', 
                                alignItems: 'center', 
                                justifyContent: 'center',
                                bgcolor: 'primary.main', 
                                color: 'white', 
                                width: 24, 
                                height: 24, 
                                borderRadius: '50%',
                                fontSize: 14
                              }}
                            >
                              {extractedContent?.totalImages || 0}
                            </Box>
                          </ListItemIcon>
                          <ListItemText 
                            primary="Images included"
                            primaryTypographyProps={{ variant: 'body2' }}
                          />
                        </ListItem>
                      </List>
                    </CardContent>
                  </Card>
                </Grid>
                
                <Grid item xs={12} sm={6}>
                  <Card variant="outlined" sx={{ height: '100%' }}>
                    <CardContent>
                      <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold' }}>
                        Output Format
                      </Typography>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box sx={{ 
                          mr: 2, 
                          color: formatStyles[format]?.color || theme.palette.primary.main 
                        }}>
                          {formatStyles[format]?.icon || <SlideshowIcon />}
                        </Box>
                        <Box>
                          <Typography variant="body2">
                            {formatStyles[format]?.name || format?.toUpperCase()} Format
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {format === 'pptx' ? 'Editable in Microsoft PowerPoint' : 'Compatible with all PDF viewers'}
                          </Typography>
                        </Box>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>
              </Grid>
              
              <Box sx={{ display: 'flex', justifyContent: 'center' }}>
                <Button 
                  variant="contained" 
                  color="primary" 
                  size="large"
                  startIcon={<BuildIcon />}
                  onClick={handleBuild}
                  disabled={!extractedContent || !format}
                  sx={{ px: 4, py: 1 }}
                >
                  Build {formatStyles[format]?.name || format?.toUpperCase()} Presentation
                </Button>
              </Box>
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );
};

export default PresentationBuilder;

